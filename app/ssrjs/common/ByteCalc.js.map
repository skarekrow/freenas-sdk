{"version":3,"sources":["app/jsx/common/ByteCalc.js"],"names":[],"mappings":"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","file":"app/jsx/common/ByteCalc.js","sourcesContent":["// BYTE CALCULATOR\n// ===============\n// Set of common tools used to convert units for data.\n\n\"use strict\";\n\nconst UNITS = [ \"K\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\" ];\nconst METRIC_PREFIX =\n  [ \"kilo\"\n  , \"mega\"\n  , \"giga\"\n  , \"tera\"\n  , \"peta\"\n  , \"exa\"\n  , \"zetta\"\n  ];\nconst IEC_PREFIX =\n  [ \"kibi\"\n  , \"mebi\"\n  , \"gibi\"\n  , \"tebi\"\n  , \"pebi\"\n  , \"exbi\"\n  , \"zebi\"\n  ];\n\nclass ByteCalc {\n\n  // Convert a string that looks like \"10KB\" or \"117 kibibytes\" into a Number\n  // equal to the equivalent number of bytes. This is a counterpart to the\n  // humanize() method. The unit suffix (if provided) is\n  static convertString ( size ) {\n\n    let parsedSize = size.replace( /[^a-z0-9.]/gi, \"\" )\n                         .split( /([a-z]+)/gi, 2 );\n\n    let quantity = Array.isArray( parsedSize )\n                   && parsedSize[0]\n                 ? Number( parsedSize[0] )\n                 : null;\n    let units = Array.isArray( parsedSize )\n                && parsedSize[1]\n              ? String( parsedSize[1] )\n              : null;\n\n    return this.toBytes.call( this, quantity, units );\n  }\n\n  // Converts between an abbreviation like \"KiB\" and the long form name\n  // (kibibytes). This is only useful for GUI display logic and should not be\n  // overloaded to perform actual conversions.\n  static getUnitName ( abbr ) {\n    if ( typeof abbr !== \"string\" ) {\n      throw new Error( \"ByteCalc.getUnitName only accepts strings: use an \"\n                     + \"abbreviation like 'KB', or 'KiB'\"\n                     );\n    } else {\n      let names;\n      let type = this.determineFormat( abbr );\n\n      if ( type === \"IEC\" ) {\n        names = IEC_PREFIX;\n      } else if ( type === \"METRIC\" ) {\n        names = METRIC_PREFIX;\n      }\n\n      return names[ UNITS.indexOf( abbr[0] ) ] + \"bytes\";\n    }\n  }\n\n  // Conversely, this gets the abbreviation, given a long form name\n  // ( \"kibibytes\" becomes \"KiB\" ).\n  static getUnitAbbr ( name ) {\n    if ( typeof name !== \"string\" ) {\n      throw new Error( \"ByteCalc.getUnitAbbr only accepts strings: use a \"\n                     + \"name like 'kilobytes', or 'mebibits'\"\n                     );\n    } else {\n      let suffix;\n      let type = this.determineFormat( name );\n\n      if ( type === \"IEC\" ) {\n        suffix = \"iB\";\n      } else if ( type === \"METRIC\" ) {\n        suffix = \"B\";\n      }\n\n      return UNITS[ UNITS.indexOf( name[0].toUpperCase() ) ] + suffix;\n    }\n  }\n\n  // Figure out the numeric base which corresponds to the string provided. This\n  // helps back-convert from other units to bytes, since it will give you the\n  // base to use in Math.log/Math.pow\n  static determineFormat ( units ) {\n    if ( units\n       && ( units.length === 3\n          | units.indexOf( \"bibyte\" ) > -1\n          )\n       ) {\n      return \"IEC\";\n    } else {\n      return \"METRIC\";\n    }\n    // Since this function might receive null or false, the fallthrough case is\n    // to render everything in metric units (more likely). Unless these specific\n    // targets are met, we won't use IEC.\n  }\n\n  // Converts from a known quantity and unit into bytes, which is the begining\n  // of all other operations. This avoids the inherent awkwardness in trying to\n  // turn TB into MiB, for instance\n  static toBytes ( quantity, unit ) {\n    const format = this.determineFormat( unit );\n    const identifier = unit\n                     ? unit[0].toUpperCase()\n                     : null;\n    const exponent = UNITS.indexOf( identifier ) + 1;\n\n    let base;\n\n    if ( format === \"METRIC\" ) {\n      base = 1000;\n    } else if ( format === \"IEC\" ) {\n      base = 1024\n    }\n\n    if ( exponent > 0 ) {\n      return Number( quantity ) * Math.pow( base, exponent );\n    } else {\n      return Number( quantity )\n    }\n  }\n\n  // Creates a human-friendly string out of a number of bytes. The output should\n  // resemble something that any good file browser would show you, intelligently\n  // rendering the biggest possible unit with two decimal places. This function\n  // can be instructed to output metric or IEC (default is metric). The\n  // `verbose` option will output \"megabytes\" instead of \"MB\"\n  static humanize ( bytes, IEC, verbose ) {\n    const base = IEC\n               ? 1024\n               : 1000;\n\n    const exponent = ( Math.abs( bytes ) < base )\n                   ? 0\n                   : Math.floor( Math.log( bytes ) / Math.log( base ) );\n\n    const finalSize = ( bytes / Math.pow( base, exponent ) );\n\n    let units = \"\";\n    let suffix = \"\";\n    let output = \"\";\n\n    if ( verbose ) {\n      if ( exponent > 0 ) {\n        units = IEC\n              ? IEC_PREFIX[ exponent - 1 ]\n              : METRIC_PREFIX[ exponent - 1 ];\n      }\n\n      suffix = finalSize === 1\n             ? \"byte\"\n             : \"bytes\";\n    } else {\n      // If we desire an abbreviated unit in IEC, our suffix needs an \"i\"\n      if ( IEC && exponent > 0 ) {\n        suffix = \"iB\";\n        units = UNITS[ exponent - 1 ];\n      }\n    }\n\n    // If we're only on bytes or kilobytes, don't bother showing decimal places\n    if ( exponent <= 1 ) {\n      output = Math.floor( finalSize );\n    } else {\n      output = finalSize.toFixed( 2 );\n    }\n\n    return output + \" \" + units + suffix;\n  }\n\n}\n\nexport default ByteCalc;\n"]}