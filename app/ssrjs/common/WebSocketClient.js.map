{"version":3,"sources":["app/jsx/common/WebSocketClient.js"],"names":[],"mappings":"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","file":"app/jsx/common/WebSocketClient.js","sourcesContent":["// WEBSOCKET CLIENT\n// ================\n// A simple base class for the WebSocket clients used by FreeNAS 10. Implements\n// some shared functionality that all WS clients rely on.\n\n\"use strict\";\n\nimport _ from \"lodash\";\n\nimport DebugLogger from \"./DebugLogger\";\n\nconst DL = new DebugLogger( \"MIDDLEWARE_CLIENT_DEBUG\" );\n\n// Modified fibonacci series to use with stepped timeout\nconst MODFIBONACCI = [ 5000, 8000, 13000, 21000, 34000 ];\n\n// Timer object (code taken from: http://stackoverflow.com/questions/3144711/...\n// ...javascript-find-the-time-left-in-a-settimeout/20745721#20745721)\n// the above code is modified to be able to suit what we need it to do\n// This is primarily needed so that the reconnection interval can be\n// obtained at the same time while the timer is in use.\n// delay is to be specified in milliseconds (example 10000 for 10 seconds)\nfunction ReconnectTimer ( doAfter, delay ) {\n  let idTimeout, idInterval, running;\n  let remaining = 0;\n  let updateFunc = function () {};\n  let modAfter = function ( ) {\n    running = false;\n    remaining = 0;\n    doAfter();\n  };\n  if ( delay && typeof delay !== \"undefined\" ) {\n    remaining = delay;\n  }\n\n  let myCusTimeout = function  ( code, delay, listener, interval ) {\n    let elapsed = 0;\n    let h;\n    h = setInterval( function () {\n      elapsed += interval;\n      if ( elapsed < delay ) {\n        listener( delay - elapsed );\n      } else {\n        clearInterval( h );\n      }\n    }, interval );\n    return [ h, setTimeout( code, delay ) ];\n  };\n\n  let modUpdateFunc = function ( t ) {\n    remaining = t;\n    updateFunc( t );\n  };\n\n  this.setUpdateFunc = function ( foo ) {\n    updateFunc = foo;\n  };\n\n  this.start = function ( delay ) {\n    if ( delay ) {\n      remaining = delay;\n    }\n    running = true;\n    [ idInterval, idTimeout ] = myCusTimeout( modAfter\n                                             , remaining\n                                             , modUpdateFunc\n                                             , 100 );\n  };\n\n  this.pause = function ( ) {\n    running = false;\n    clearTimeout( idTimeout );\n    clearInterval( idInterval );\n  };\n\n  this.getTimeLeft = function ( ) {\n    if ( running ) {\n      return remaining;\n    } else {\n      remaining = 0;\n      return 0;\n    }\n  };\n\n  this.isRunning = function ( ) {\n    if ( remaining === 0 ) { running = false };\n    return running;\n  };\n\n  this.stop = function ( ) {\n    clearTimeout( idTimeout );\n    clearInterval( idInterval );\n    running = false;\n    this.remaining = 0;\n  };\n\n  this.reconnectNow = function ( ) {\n    this.stop();\n    doAfter();\n  };\n};\n\n\nclass WebSocketClient {\n\n  constructor () {\n    // Counter for stepped timeout\n    this.k = -1;\n    this.socket = null;\n\n    // Publically accessible reconectHandle\n    this.reconnectHandle = new ReconnectTimer ( function ( ) {\n      var protocol = ( window.location.protocol === \"https:\" ?\n                         \"wss://\" : \"ws://\" );\n      this.connect( protocol + document.domain + \":5000/socket\" );\n    }.bind( this ) );\n  }\n\n\n  // This method should only be called when there's no existing connection. If\n  // for some reason, the existing connection should be ignored and overridden,\n  // supply `true` as the `force` parameter.\n  connect ( url, force ) {\n    if ( window.WebSocket ) {\n      if ( !this.socket || force ) {\n\n        if ( DL.reports( \"connection\" ) ) {\n          DL.info( \"Creating WebSocket instance\" );\n        }\n\n        if ( force ) {\n          DL.warn( \"Forcing creation of new WebSocket instance\" );\n        }\n\n        this.socket = new WebSocket( url );\n\n        _.assign( this.socket\n                , { onopen: this.handleOpen.bind( this )\n                  , onmessage: this.handleMessage.bind( this )\n                  , onerror: this.handleError.bind( this )\n                  , onclose: this.handleClose.bind( this )\n                  }\n                , this\n                );\n\n      } else if ( DL.reports( \"connection\" ) ) {\n        DL.warn( \"Attempted to create a new WebSocket connection while a \" +\n                 \"connection already exists.\"\n               );\n      }\n    } else {\n      // TODO: Visual error for legacy browsers with links to download others\n      DL.error( \"This browser doesn't support WebSockets.\" );\n    }\n  };\n\n  // Shortcut method for closing the WebSocket connection. Will also trigger\n  // `handleClose` for any cleanup that needs to happen.\n  disconnect ( code, reason ) {\n    this.socket.close( code, reason );\n  };\n\n  handleOpen () {\n    // Set stepped reconnect counter back to 0\n    this.k = -1;\n  }\n\n  handleMessage () {\n\n  }\n\n  handleError () {\n\n  }\n\n  handleClose () {\n    this.socket = null;\n    if ( this.reconnectHandle.isRunning() ) {\n      this.reconnectHandle.stop();\n    }\n    // Increase k in a cyclic fashion (it goes back to 0 after reachin 4)\n    this.k = ++this.k % MODFIBONACCI.length;\n    this.reconnectHandle.start( MODFIBONACCI[this.k] );\n    // Uncomment the below if debugging the reconnect timer, else let it be!\n    // var _this = this;\n    // ( function checkReconnectHandle ( ) {\n    //     let tvar = 0;\n    //     setTimeout( function () {\n    //       if ( _this.reconnectHandle.isRunning() ) {\n    //         let temp = Math.round( _this.reconnectHandle.getTimeLeft()/1000);\n    //         if ( temp !== tvar ) {\n    //           tvar = temp;\n    //           console.log( tvar, \" seconds to reconnection...\" );\n    //         };\n    //         checkReconnectHandle();       // Call checkReconnectHandle again\n    //       }\n    //     }, 1000 );\n    //   }() );\n  }\n\n}\n\nexport default WebSocketClient;\n"]}