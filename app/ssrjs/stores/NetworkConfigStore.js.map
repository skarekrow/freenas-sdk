{"version":3,"sources":["app/jsx/stores/NetworkConfigStore.js"],"names":[],"mappings":";;;AAGA,YAAY,CAAC;;;;sBAEC,QAAQ;;;;sBACO,QAAQ;;2CAEP,iCAAiC;;;;yCACnC,+BAA+B;;0CAEvB,gCAAgC;;;;AAEpE,IAAM,YAAY,GAAG,QAAQ,CAAC;AAC9B,IAAM,WAAW,GAAG,iBAAiB,CAAC;;AAEtC,IAAI,mBAAmB,GAAG,KAAK,CAAC;AAChC,IAAI,cAAc,GAAG,EAAE,CAAC;;AAGxB,IAAI,kBAAkB,GAAG,oBAAE,MAAM,CAAE,EAAE,EAAE,QAd9B,YAAY,CAc+B,SAAS,EAAE;;AAE7D,YAAU,EAAE,sBAAY;AACpB,QAAI,CAAC,IAAI,CAAE,YAAY,CAAE,CAAC;GAC3B;;AAED,mBAAiB,EAAE,2BAAW,QAAQ,EAAG;AACvC,QAAI,CAAC,EAAE,CAAE,YAAY,EAAE,QAAQ,CAAE,CAAC;GACnC;;AAED,sBAAoB,EAAE,8BAAW,QAAQ,EAAG;AAC1C,QAAI,CAAC,cAAc,CAAE,YAAY,EAAE,QAAQ,CAAE,CAAC;GAC/C;;AAED,eAAa,EAAE,yBAAY;AACzB,WAAO,WAAW,CAAC;GACpB;;AAED,sBAAoB,EAAE,gCAAY;AAChC,WAAO,mBAAmB,CAAC;GAC5B;;AAED,kBAAgB,EAAE,4BAAY;AAC5B,WAAO,cAAc,CAAC;GACvB;;CAEJ,CAAC,CAAC;;AAEH,kBAAkB,CAAC,aAAa,GAAG,yCAAkB,QAAQ,CAC3D,UAAW,OAAO,EAAG;AACnB,MAAI,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;;AAE5B,UAAS,MAAM,CAAC,IAAI;;AAElB,SAAK,2BA7CF,WAAW,CA6CG,sBAAsB;;AAErC,oBAAc,GAAG,MAAM,CAAC,aAAa,CAAC;AACtC,wBAAkB,CAAC,UAAU,EAAE,CAAC;AAChC,YAAM;;AAAA,AAER,SAAK,2BAnDF,WAAW,CAmDG,gBAAgB;;AAE/B,UAAI,IAAI,GAAG,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC;AACjC,UAAI,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC;;;;AAI3B,UAAI,WAAW,GAAG,IAAI,CAAE,MAAM,CAAE,KAAK,WAAW,IAC7B,UAAU,CAAE,WAAW,CAAE,KAAK,QAAQ,CAAC;;AAE1D,UAAK,WAAW,EAAG;AACjB,2BAAmB,GAAG,KAAK,CAAC;AAC5B,0BAAkB,CAAC,UAAU,EAAE,CAAC;OACjC;;AAED,YAAM;;AAAA,AAER,SAAK,2BApEF,WAAW,CAoEG,2BAA2B;;AAE1C,yBAAmB,GAAG,IAAI,CAAC;AAC3B,wBAAkB,CAAC,UAAU,EAAE,CAAC;AAChC,YAAM;AAAA,GACT;CACF,CACF,CAAC;;AAEF,MAAM,CAAC,OAAO,GAAG,kBAAkB,CAAC","file":"app/jsx/stores/NetworkConfigStore.js","sourcesContent":["// Network Config Flux Store\n// =========================\n\n\"use strict\";\n\nimport _ from \"lodash\";\nimport { EventEmitter } from \"events\";\n\nimport FreeNASDispatcher from \"../dispatcher/FreeNASDispatcher\";\nimport { ActionTypes } from \"../constants/FreeNASConstants\";\n\nimport NetworkConfigMiddleware from \"../middleware/GroupsMiddleware\";\n\nconst CHANGE_EVENT = \"change\";\nconst UPDATE_MASK = \"network.changed\";\n\nvar _localUpdatePending = false;\nvar _networkConfig = {};\n\n\nvar NetworkConfigStore = _.assign( {}, EventEmitter.prototype, {\n\n  emitChange: function () {\n      this.emit( CHANGE_EVENT );\n    }\n\n  , addChangeListener: function ( callback ) {\n      this.on( CHANGE_EVENT, callback );\n    }\n\n  , removeChangeListener: function ( callback ) {\n      this.removeListener( CHANGE_EVENT, callback );\n    }\n\n  , getUpdateMask: function () {\n      return UPDATE_MASK;\n    }\n\n  , isLocalUpdatePending: function () {\n      return _localUpdatePending;\n    }\n\n  , getNetworkConfig: function () {\n      return _networkConfig;\n    }\n\n});\n\nNetworkConfigStore.dispatchToken = FreeNASDispatcher.register(\n  function ( payload ) {\n    var action = payload.action;\n\n    switch ( action.type ) {\n\n      case ActionTypes.RECEIVE_NETWORK_CONFIG:\n\n        _networkConfig = action.networkConfig;\n        NetworkConfigStore.emitChange();\n        break;\n\n      case ActionTypes.MIDDLEWARE_EVENT:\n\n        let args = action.eventData.args;\n        let updateData = args.args;\n\n        // The second check here should never fail, but I'm putting it\n        // here out of an overabundance of caution.\n        let validUpdate = args[ \"name\" ] === UPDATE_MASK\n                        && updateData[ \"operation\" ] === \"update\";\n\n        if ( validUpdate ) {\n          _localUpdatePending = false;\n          NetworkConfigStore.emitChange();\n        }\n\n        break;\n\n      case ActionTypes.RECEIVE_NETWORK_UPDATE_TASK:\n\n        _localUpdatePending = true;\n        NetworkConfigStore.emitChange();\n        break;\n    }\n  }\n);\n\nmodule.exports = NetworkConfigStore;\n"]}