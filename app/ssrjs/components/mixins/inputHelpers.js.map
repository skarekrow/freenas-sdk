{"version":3,"sources":["app/jsx/components/mixins/inputHelpers.jsx"],"names":[],"mappings":"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","file":"app/jsx/components/mixins/inputHelpers.jsx","sourcesContent":["// INPUT HELPER MIXIN\n// ==================\n// Provides utility functions for generating common parts of input fields and\n// maintaining proper local and remote state.\n\n\"use strict\";\n\nimport _ from \"lodash\";\nimport React from \"react\";\n\nmodule.exports = {\n\n  // Takes an array and turns it into an array of options suitable for use\n  // in a select box or multi-select box.\n  generateOptionsList: function ( options, selectionKey, displayKey ) {\n    let optionList = [];\n\n    _.forEach( options\n             , function ( opt ) {\n               let element = ( <option value = { opt[ selectionKey ] }\n                                       label = { opt[ displayKey\n                                                    ? displayKey\n                                                    : selectionKey\n                                                    ]\n                                               }\n                               />\n                             );\n               optionList.push( element );\n             }\n             , this\n             );\n\n    return optionList;\n  }\n\n  // Check if a given attribute is mutable according to the given data keys.\n  // This is a PITA because this information is buried in an object in an\n  // array in a prop, which cannot be helped.\n  , isMutable: function ( attribute, dataKeys ) {\n    return ( _.find( dataKeys\n                   , function ( dataKey ) {\n                     return ( dataKey.key === attribute );\n                   }\n                   , this\n                   ).mutable\n           );\n  }\n\n  // Returns an object containin the mutable fields from the item in nextProps.\n  // A malformed nextProps will result in an empty array.\n  , removeReadOnlyFields: function ( item, keys ) {\n    let outgoingItem = {};\n\n    _.forEach( item, function ( value, key ) {\n      let keyContent = _.find( keys\n                             , function findKey ( checkKey ) {\n                               return ( checkKey.key === key );\n                             }\n                             , this\n                             );\n\n      // TODO: If we want to accept arbitrary properies, we will need more\n      // sophisticated handling here.\n\n      // Do not include unknown propertie s.\n      if ( keyContent ) {\n        // Do not include read-only fields\n        if ( keyContent[ \"mutable\" ] ) {\n          outgoingItem[ key ] = value;\n        }\n      }\n    }\n    , this\n    );\n\n    return outgoingItem;\n  }\n\n  // Remote state is set at load time and reset upon successful changes. This\n  // is used to highlight and submit only genuinely changed values.\n  , setRemoteState: function ( incomingProps ) {\n    let dataKeys = incomingProps.viewData[ \"format\" ][ \"dataKeys\" ];\n    let nextRemoteState = this.removeReadOnlyFields( incomingProps.item\n                                                   , dataKeys\n                                                   );\n\n    if ( _.isEmpty( nextRemoteState ) ) {\n      console.warn( \"Remote State could not be created!\"\n                  + \"Check the incoming props:\" );\n      console.warn( incomingProps );\n    }\n\n    // TODO: What exactly should be returned if setting the remote state is\n    // going to fail?\n    return nextRemoteState;\n  }\n\n  // Deals with input from different kinds of input fields.\n  // TODO: Extend with other input fields and refine existing ones as necessary.\n  , processFormInput: function ( event, value, dataKey ) {\n    let inputValue;\n\n    switch ( event.target.type ) {\n\n      case \"checkbox\" :\n        inputValue = event.target.checked;\n        break;\n\n      case \"select\":\n      case \"text\":\n      case \"textarea\":\n      case \"array\":\n      default:\n        inputValue = this.parseInputType( event.target.value, value, dataKey );\n        break;\n    }\n\n    return inputValue;\n  }\n\n  // Different handling for different types of data types\n  , parseInputType: function ( input, value, dataKey ) {\n    let output;\n\n    switch ( dataKey.type ) {\n      case \"string\":\n        output = input;\n        break;\n\n      case \"array\":\n        output = value;\n        break;\n\n      case \"integer\":\n      case \"number\":\n        // at this time all the numbers we actually edit are integers.\n        // FIXME: Correct handling if we ever need to parse non-integer\n        // numbers\n        // FIXME: Make sure numbers that must be integers are labeled as such\n        // in the schema\n        output = _.parseInt( input );\n        break;\n\n      default:\n        output = input;\n        break;\n    }\n\n    return output;\n  }\n\n  // Requires that locallyModifiedValues be used to store changes made by the\n  // user and mixedValues be used to store the data for display. remoteState\n  // must be the last item receieved from the middleware, as it will be used for\n  // comparison.\n  // See UserItem for typical usage.\n  // This is specifically for edit views, not add entity views.\n  , editHandleValueChange: function ( key, event ) {\n    let value = this.refs[ key ].getValue();\n    let newLocallyModified = this.state.locallyModifiedValues;\n\n    let dataKey = _.find( this.state.dataKeys\n                        , function ( dataKey ) {\n                          return ( dataKey.key === key );\n                        }\n                        , this\n                    );\n\n    let inputValue = this.processFormInput( event, value, dataKey );\n\n    // We don't want to submit non-changed data to the middleware, and it's\n    // easy for data to appear \"changed\", even if it's the same. Here, we\n    // check to make sure that the input value we've just receieved isn't the\n    // same as what the last payload from the middleware shows as the value\n    // for the same key. If it is, we `delete` the key from our temp object\n    // and update state.\n    if ( _.isEqual( this.state.remoteState[ key ], inputValue ) ) {\n      delete newLocallyModified[ key ];\n    } else {\n      newLocallyModified[ key ] = inputValue;\n    }\n\n    // mixedValues functions as a clone of the original item passed down in\n    // props, and is modified with the values that have been changed by the\n    // user. This allows the display components to have access to the\n    // \"canonically\" correct item, merged with the un-changed values.\n    this.setState( { locallyModifiedValues : newLocallyModified\n                   , mixedValues : _.assign( _.cloneDeep( this.props.item )\n                                           , newLocallyModified\n                                           )\n                   }\n    );\n  }\n\n  , submissionRedirect: function ( valuesToSend ) {\n    let routing = this.props.viewData.routing;\n    let format = this.props.viewData.format;\n    let params = {};\n    let newEntityPath;\n\n    if ( valuesToSend[ format[ \"primaryKey\" ] ] ) {\n      newEntityPath = valuesToSend[ format[ \"primaryKey\" ] ];\n      params[ routing[ \"param\" ] ] = newEntityPath;\n      this.context.router.transitionTo( routing[ \"route\" ]\n                                      , params\n                                      );\n    } else {\n      this.props.handleViewChange( \"view\" );\n    }\n  }\n};\n"]}